{"meta":{"title":"云原生笔记","subtitle":null,"description":"最怕你一生碌碌无为，还安慰自己平凡可贵","author":"LIANGBIN@PA","url":"http://liangbin.xyz","root":"/"},"pages":[{"title":"tags","date":"2019-12-13T02:06:51.000Z","updated":"2019-12-13T09:52:51.647Z","comments":false,"path":"tags/index.html","permalink":"http://liangbin.xyz/tags/index.html","excerpt":"","text":""},{"title":"关于作者","date":"2019-12-14T06:41:57.000Z","updated":"2019-12-14T06:43:36.436Z","comments":true,"path":"about/index.html","permalink":"http://liangbin.xyz/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Pod对象字段解析","slug":"Pod对象字段解析","date":"2018-02-03T11:24:29.000Z","updated":"2020-01-13T11:29:30.446Z","comments":true,"path":"2018/02/03/Pod对象字段解析/","link":"","permalink":"http://liangbin.xyz/2018/02/03/Pod%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90/","excerpt":"","text":"简介Pod是k8s中容器编排调度的最小单位。初学者最常用的命令之一就是 kubectl get pod。平常我们不直接写Pod的yaml文件，但是当我们以kubectl describe 命令或者 kubectl get pod -o yaml查看Pod排错时，经常看到五花八门的各种字段。梳理Pod对象数据结构，熟悉其各字段，有助于我们加深对Pod的理解，更能帮助我们快速定位问题所在。废话不多说，来看源码。 代码代码位置：kubernetes\\pkg\\apis\\core\\type.go // Pod is a collection of containers, used as either input (create, update) or as output (list, get). type Pod struct { metav1.TypeMeta // +optional metav1.ObjectMeta // Spec defines the behavior of a pod. // +optional Spec PodSpec // Status represents the current information about a pod. This data may not be up // to date. // +optional Status PodStatus }k8s中的多数对象都由这三个字段构成: metadata，spec，status。从注释，我们先可以明显看到Pod的定义，是一系列容器的集合。这是首先要注意的一个点，Pod不等同于容器，而是容器的集合。深入看PodSpec。 type PodSpec struct { Volumes []Volume //挂载到Pod内容器的卷 InitContainers []Container //执行初始化操作的容器 Containers []Container //Pod中的容器，至少有一个。 EphemeralContainers []EphemeralContainer //1.16版本新特性，临时容器，用于排查故障 RestartPolicy RestartPolicy //Pod内所有容器的重启策略，可取Always、OnFailure、Never.默认是Always TerminationGracePeriodSeconds *int64 //终止或删除Pod时的宽限期，默认为30秒，允许容器内的应用进行必要操作以实现优雅退出。 ActiveDeadlineSeconds *int64 //存活时间，超过这个时间系统将会终止Pod运行。常用于Job。 DNSPolicy DNSPolicy // Pod中的DNS策略，配合DNSConfig共同起作用 NodeSelector map[string]string //节点选择器，配合亲和性、反亲和性以实现Pod的定向调度 ServiceAccountName string //Pod内的服务账号名 AutomountServiceAccountToken *bool //是否为serivce account 自动挂载 API 凭证 NodeName string //节点名，不为空时调度器调度Pod到相应值的节点上。 SecurityContext *PodSecurityContext //Pod级别的安全上下文，用于控制Pod内权限安全层级和Pod内公共的容器配置 ImagePullSecrets []LocalObjectReference //拉取镜像的secret，只能被kubelet访问 Hostname string //配合Subdomain起作用，指定pod的hostname，指定后形式为&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt; Subdomain string Affinity *Affinity //亲和性，约束Pod可调度到的计算节点 SchedulerName string //指定自定义调度器负责该Pod的调度过程，未指定则交由默认调度器调度 Tolerations []Toleration //容忍,配合污点共同约束Pod的调度。 HostAliases []HostAlias //注入host和对应IP信息到Pod内的/etc/hosts文件， PriorityClassName string //和Priority共同决定Pod优先级 Priority *int32 PreemptionPolicy *PreemptionPolicy //抢占策略，值为Never 或 PreemptLowerPriority，默认为 PreemptLowerPriority，以保障高优先级Pod运行 DNSConfig *PodDNSConfig //Pod中的DNS配置，配合DNSPolicy共同起作用 ReadinessGates []PodReadinessGate //扩展的就绪探针机制 RuntimeClassName *string //容器运行时类 Overhead ResourceList //Pod透支列表 EnableServiceLinks *bool //同namespaces下的service信息是否注入到Pod的环境变量中，默认值为true TopologySpreadConstraints []TopologySpreadConstraint //容器的拓扑分布约束 }归类Pod的对象的字段，基本上可以都是关于Pod的生命周期的。 要创建一个Pod，必然涉及到调度。k8s本质上是个编排调度系统，可以看到Pod的字段中有相当多一部分与调度有关：节点选择器，亲和性，容忍，自定义调度器，抢占，优先级等。其目的是尽可能的让Pod分配到最合适的节点。 调度完成后，要拉取镜像启动容器，进行必要的初始化工作。有InitContainer，ImagePullSecrets。 而和Pod运行或公共配置，则有 DNSPolicy、 DNSConfig、 Hostname、 Subdomain、HostAliases、EnableServiceLinks、RuntimeClassName等 重启或退出相关字段，RestartPolicy、TerminationGracePeriodSeconds、ActiveDeadlineSeconds。 TipsInitContainer可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。例如，公司Java应用的基础镜像是JDK8，如果个别团队需要一些特殊的工具或服务，如sshd、python等，没有必要重新再打一个包含这些工具的JDK8基础镜像，使用InitContainer即可达到目的。另外，InitContainer能以不同于Pod内应用容器的文件系统视图运行。如果Pod定义了多个InitContainer则依次执行。 EphemeralContainers当容器崩溃或容器镜像中不包含调试工具时，使用kubectl exec命令进行故障排查不足，EphemeralContainers对于交互式故障处理很有用。使用EphemeralContainers时，启用进程命名空间共享很有帮助，可以查看其他容器中的进程。 Security Context可以限制不可信容器的行为，保护系统和其他容器不受其影响。Kubernetes提供了三种配置Security Context的方法Container-level Security Context 仅应用到指定的容器Pod-level Security Context 应用到Pod内所有容器以及VolumePod Security Policies（PSP） 应用到集群内部所有Pod以及Volum 关于Pod字段的笔记就先蜻蜓点水止于此，其中许多字段都还可以深入展开。","categories":[],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://liangbin.xyz/tags/Kubernetes/"}]},{"title":"go语言中的数组和切片","slug":"go数组和切片的区别","date":"2017-11-07T00:55:29.000Z","updated":"2019-12-12T02:27:11.804Z","comments":true,"path":"2017/11/07/go数组和切片的区别/","link":"","permalink":"http://liangbin.xyz/2017/11/07/go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"数组数组（array）是go语言编程中较为常用的数据结构之一，数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。","text":"数组数组（array）是go语言编程中较为常用的数据结构之一，数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。 和在c语言中不同，数组在go语言中是一个值类型，是真真实实的数组，而不是一个纸箱数组内存起始位置的指针，也不能和同类型的指针进行转化。所有的值类型变量在赋值和作为参数传递时都将进行一次复制动作。如果将数组作为函数的参数类型，则在函数调用时，该参数将发生数据赋值。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是传入数组的一份副本。 数组的声明和初始化var variable_name [SIZE] variable_type var balance [10] float32SIZE即数组长度，variable_type表示数组存储类型，variable_name为数组名。在Go语言中，数组长度定义后就不可更改。声明长度SIZE可以是常量，或者是常量表达式（常量表达式是指在编译期间即可计算结果的表达式）。数组的长度属于数组类型的一部分，是其一个内置常量。可通过内建函数len()获取。 package main import( &quot;fmt&quot; ) func main(){ var arr1 [5]int arr2 := [5]int{1, 2, 3, 4, 5} //指定长度为5，并赋5个初始值 arr3 := [5]int{1, 2, 3} //指定长度为5，对前3个元素进行赋值，其他元素为零值 arr4 := [5]int{4: 1}//指定长度为5，对第5个元素赋值 arr5 := [...]int{1, 2, 3, 4, 5} //不指定长度，对数组赋以5个值 arr6 := [...]int{8: 1} //不指定长度，对第9个元素（下标为8）赋值1 fmt.Println(arr1, arr2, arr3, arr4, arr5, arr6) }如上，输出结果为： [root@localhost mygo]# go run test.go [0 0 0 0 0] [1 2 3 4 5] [1 2 3 0 0] [0 0 0 0 1] [1 2 3 4 5] [0 0 0 0 0 0 0 0 1]数组的值传递package main import( &quot;fmt&quot; ) func modify(arr [5]int){ arr[0] = 10 fmt.Println(&quot;In modify(), arr values:&quot;, arr) } func main(){ arr := [5]int{1, 2, 3, 4, 5} modify(arr) fmt.Println(&quot;In main(), arr values:&quot;, arr) }输出结果为 [root@localhost mygo]# go run test.go In modify(), arr values: [10 2 3 4 5] In main(), arr values: [1 2 3 4 5]注意：在定义多维数组时，仅第一维度允许使用“…”，内置函数len和cap返回的都是第一维度长度。如果元素类型本身支持“==”“！=”操作符，那么数组也支持此操作。 切片go语言中，切片(slice)是对数组的抽象，其本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性并将数据读写操作限定在指定区域内。上文提到，go数组长度是不可改变的，在特定场景中就不太实用。go提供了一种较为灵活且功能更为强悍的内置类型——切片。与数组相比，切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 另外，前文提到go数组是值类型，赋值和函数传参操作都会赋值整个数组数据。如果在数组大小非常大的情况下，发生值传递，这样将会消耗掉大量内存。而切片是引用传递，用来代替数组传参可以避免复制开销。 切片的声明和初始化//切片不需要说明长度 var identifier []type //使用make()函数来创建切片 var slice1 []type = make([]type, len) //简写 slice1 := make([]type, len)注意上述方式的区别。第一种仅定义了一个[]type类型变量，并未执行初始化语句。后两种则用初始化表达式完成了全部创建过程。 切片的结构type slice struct { array unsafe.pointer len int cap int }切片本身只是个只读对象，其工作机制类似数组指针的一种包装。 示例： 12345678910x := [...]int&#123;0,1,2,3,4,5,6,7,8,9&#125;expression slice len cap ------------+-----------------------+-------+---------+------------x[:] [0 1 2 3 4 5 6 7 8 9] 10 10 x[0:len(x)]x[2:5] [2 3 4] 3 8 x[2:5:7] [2 3 4] 3 5x[4:] [4 5 6 7 8 9] 6 6 x[4:len(x)] x[:4] [0 1 2 3] 4 10 x[0:4] x[:4:6] [0 1 2 3] 4 6 x[0:4:6] 异同数组和切片同属集合类。切片的设计场景弥补了数组固定长度带来的不变，在使用切片时候能享受数组的便利，又可以不必过于在意数组固定长度带来的束缚。最重要的区别，数组的值其长度是固定的，而切片类型的值是可变长的。 切片类似java中的list，长度可以自动地随着其中元素数量增长而动态扩容，同时数量减少不会缩容。 切片可以看成是对数组的封装。切片的底层数据结构中，包含数组。切片的容量实际上代表了底层数组的长度。 只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容，只会使得紧靠切片窗口右边的（底层数组中的）元素被新的元素替换掉。","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://liangbin.xyz/tags/go/"}]},{"title":"云原生相关站点","slug":"云原生相关站点","date":"2017-09-12T09:17:10.000Z","updated":"2019-12-12T10:17:17.909Z","comments":true,"path":"2017/09/12/云原生相关站点/","link":"","permalink":"http://liangbin.xyz/2017/09/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%9B%B8%E5%85%B3%E7%AB%99%E7%82%B9/","excerpt":"IBM Developer Kubernetes Atlas Red Hat OpenShift Blog","text":"IBM Developer Kubernetes Atlas Red Hat OpenShift Blog Rancher Labs’ Kubernetes Blog CNCF官网 AWS Blog learnk8s blog 阿里云栖社区 腾讯云+社区 华为云社区 kubernetes handbook","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://liangbin.xyz/tags/kubernetes/"}]},{"title":"Android图像处理中踩过的一些坑","slug":"Android图像处理中踩过的一些坑","date":"2016-07-17T10:25:29.000Z","updated":"2019-12-12T02:26:52.388Z","comments":true,"path":"2016/07/17/Android图像处理中踩过的一些坑/","link":"","permalink":"http://liangbin.xyz/2016/07/17/Android%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"关于图片的操作一直是Andriod开发中备受关注的一个点，特别是新手，一不注意分分钟就会碰到OOM异常。本文总结一下，图片处理这一块，踩过的坑有哪些。","text":"关于图片的操作一直是Andriod开发中备受关注的一个点，特别是新手，一不注意分分钟就会碰到OOM异常。本文总结一下，图片处理这一块，踩过的坑有哪些。 **问题1：在图库（照片墙）中显示的是图片A，点击图片显示的大图是另外一张图片B，而图片B实际上应该显示的图片（某一张图片如此，不是所有图片都不一致）。** 解决过程： 第一反应是跳转时，携带的图片路径错误导致的，但是很快排除这个原因了。因为只有某一张图片如此，多数图片都可以正确显示。 然后以为是机型问题，遂搁置。后来在模拟器上测试，由于模拟器的相册图片很少，很快就定位到，出问题的图片是一张临时保存的图片crop_tmp.jpg，它总是被每次截图后保存的图片以同样的命名覆盖。 通过网上查找资料，推测可能是图片的缩略图和原图不一致，不一致的原因是因为图片直接以同名覆盖时，只更改了原图而缩略图不变（在出现上述的问题后，只要重新debug再次进入到图库，可以看到之前出现问题的图A变为图B了，点击图B预览到的大图也是图B，一致，这个情况也支持了我上述的猜测）。后来在每次截图以同名文件覆盖后，都调用如下代码： private void deleteTmpImage(String path) { File file = new File(path); file.delete(); MediaScannerConnection.scanFile(this, new String[]{file.getAbsolutePath()}, null, new MediaScannerConnection.OnScanCompletedListener() { @Override public void onScanCompleted(String path, Uri uri) { } }); } 通知系统重新扫描媒体库。但实际上没有作用，问题依旧没有解决。 接着考虑到有可能是Fresco自身的缓存机制引起的，遂将目光转向了Fresco。先从LoadingImageView的加载图片的方法入手，打印出路径，发现图片的URI地址不规范。 //不规范写法导致bug file:/storage/emulated/0/netease/vs/crop_temp.jpg //规范写法，bug消除 file:///storage/emulated/0/netease/vs/crop_temp.jpg至此，该问题得到解决。这个问题非常隐蔽，因为第一种写法，fresco也能正确加载出图片，导致走了许多弯路。 **问题2：删除某一张图片后，在图库（照片墙）界面，该图片原来的位置会显示Fresco加载中的占位图。** 解决过程： 删除图片的代码： File file = new File(path); file.delete();这样其实还不够，删除掉一张图片之后，应该及时调用扫描一次系统媒体库，刷新数据。如下 MediaScannerConnection.scanFile(this, new String[]{file.getAbsolutePath()}, null, new MediaScannerConnection.OnScanCompletedListener() { @Override public void onScanCompleted(String path, Uri uri) { } });第一个参数是传入调用者的context,第二个参数一系列待扫描路径的数组，第三个参数是这些路径所对应的文件是属于哪些mimeType,第四个参数为扫描成功的回调。调用该静态方法后，会主动通知系统刷新图库。涉及到文件的删除修改的，都应该及时通知系统主动扫描刷新数据。 问题3：图库（照片墙）同时加载大量图片时，界面中的部分图片加载不出来。 解决过程： 原先使用的是setLoadingImageView()方法，在某一次Fresco的版本升级后，出现了上述问题。在积累一点经验之后，首先想到的是内存的问题。查看这个界面的内存占用情况。 /** * 显示图库相片时使用的方法 * * @param url * @param width * @param height */ public void setGalleryImage(final String url, int width, int height) { Uri uri = Uri.parse(url); ImageRequest imageRequest = ImageRequestBuilder .newBuilderWithSource(uri) .setResizeOptions(new ResizeOptions(width, height))//图片目标大小 .build(); DraweeController controller = Fresco.newDraweeControllerBuilder() .setOldController(getController()) .setImageRequest(imageRequest) .build(); this.setController(controller); }Resize这个选项，并不改变原始图片，它只在解码前修改内存中的图片大小。对于要展示一张实际尺寸远大于显示尺寸的图片来说，它可以有效的节省内存。但实际上这个方法也不是一劳永逸的。一方面，它不支持PNG格式，当相册同时显示多张PNG格式图片时，仍有可能出现上述问题。另一方面，通过对屏幕宽度3等分来确定剪裁的大小，这种做法也十分简单粗暴，如果正好同时加载到本地多张10+M的图片，还是会有隐患。 注意到Fresco在0.8.1版本后添加了Downsampling这个新特性，它更好的支持不同格式的压缩和裁剪，速度也比Resize更快。 **问题4：图片截图后上传成功后，服务器返回保存成功的信息，但是进入到个人主页界面的头像，却依然是之前的，没有更新。** 解决过程： 抓包发现上传的图片没有后缀名，添加jpg后缀名解决。 问题5：上传图片，后台返回服务器错误。 解决过程： 服务器端对上传的文件大小做了限制。这里需要对图片进行压缩。包括截图中出现的OOM问题，也是没有对图片进行压缩造成的。 问题6：拍照后返回的data为空 **补充：** 关于图片压缩，就得先提到图片的存在的三种形式,及如何检测大小。 文件形式 用File.length()查看大小 流的形式 将图片文件读入到内存输入流中，看它的字节数 Bitmap bigmap.getByteCount 区别是，文件形式和流的形式对图片体积大小并没有影响。即，一张图片如果存在手机上是100K,那么通过流的形式读到内存中，也只占100K内存。当图片以Bitmap形式存在是，内存会瞬间变大。500K文件形式的图片加载到内存中，以Bitmap形式存在时，占用内存可能会将近10M。 看秀品里的一个工具类ImageUtil里的两个方法： public static boolean saveBitmap2File(Bitmap bmp, int quality, StoreFile file) { boolean ret = false; OutputStream stream = null; try { stream = file.openOutputStream(); } catch (IOException e) { e.printStackTrace(); } if (stream != null) { CompressFormat format = CompressFormat.JPEG; if (bmp.hasAlpha()) { format = CompressFormat.PNG; } ret = bmp.compress(format, quality, stream); } file.close(); return ret; }这个方法可以通过制定quality参数，通过压缩图片的质量达到压缩输出的File文件的大小的效果，较小的File文件，可以方便的上传到服务器，减少流量的消耗。实际上图片的像素并没有改变,通过BitmapFactory.decodeFile到内存中时占用的内存大小并没有变化。例如一张1024x1024像素的图片来说，假定其采用ARGB8888格式（32位）存储，其占用的内存为1024x1024x4Byte，即4MB。因为像素没有改变，实际上，以Bitmap占用的内存不会有显著的减少。 /** * 解大图内存不足时尝试5次, samplesize增大 * * @author panjf * @param file * @param max 宽或高的最大值, &lt;= 0 , 能解多大解多大, &gt; 0, 最大max, 内存不足解更小 * @return */ public static Bitmap getBitmapFromFileLimitSize(String file, int max) { if (file == null) return null; Bitmap bm = null; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 1; if(max &gt; 0){ options.inJustDecodeBounds = true; // 获取这个图片的宽和高 bm = BitmapFactory.decodeFile(file, options); options.inJustDecodeBounds = false; float blW = (float) options.outWidth / max; float blH = (float) options.outHeight / max; if (blW &gt; 1 || blH &gt; 1) { if(blW &gt; blH ) options.inSampleSize = (int) (blW + 0.9f); else options.inSampleSize = (int) (blH + 0.9f); } } int i = 0; while (i &lt;= 10) { i++; try { bm = BitmapFactory.decodeFile(file, options); break; } catch (OutOfMemoryError e) { options.inSampleSize++; e.printStackTrace(); } } return bm; }作为对比，这个方法通过Bitmap.Options来缩放图片，用到采用率inSampleSize这个参数。上面这个方法，如果输入的max为0，初始化的采样率为1，采样后的图片即原图大小。内存不足时，增大采样率（采样率通常是2的N次方，如果采样率为3，会向下去一个最接近2的N次方的整数，即2，所以该方法中的while循环中，有效的解图并不足10次，但好像也不是如注释中说的尝试5次），例如采样率为4，宽高像素均为原来的1/4,采样后图片占用内存即为原来的1/16。 经过实测，多数情况下不会碰到内存不足的情况，while循环中的break语句会被执行到，因此只会解一次图。所以必须保证输入的参数max是有意义的值，才能起到压缩的效果。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://liangbin.xyz/tags/Android/"}]},{"title":"正确理解LayoutInflater.inflate()","slug":"正确理解LayoutInflater.inflate()","date":"2016-03-10T18:55:29.000Z","updated":"2019-12-12T02:27:31.840Z","comments":true,"path":"2016/03/11/正确理解LayoutInflater.inflate()/","link":"","permalink":"http://liangbin.xyz/2016/03/11/%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3LayoutInflater.inflate()/","excerpt":"平时开发的时候，加载布局经常会遇到LayoutInflater，用倒是经常用了，但是之前一直没有探究其中的细节。有疑问，当然还是要搞清楚了才放心。下面和大家讨论讨论其中的细节，涉及内容并不深奥，可能我们不在意常忽略了。如果有不当处，欢迎指正。","text":"平时开发的时候，加载布局经常会遇到LayoutInflater，用倒是经常用了，但是之前一直没有探究其中的细节。有疑问，当然还是要搞清楚了才放心。下面和大家讨论讨论其中的细节，涉及内容并不深奥，可能我们不在意常忽略了。如果有不当处，欢迎指正。 常用的获取LayoutInflater实例的方法有两种。第一种如下： @Override public View getView(int position, View convertView, ViewGroup parent) { final Context context = parent.getContext(); if (convertView == null) { LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); convertView = inflater.inflate(R.layout.view_address_item, parent, false); ... ... }另外一种方法，在效果上也是一样的： @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); ... ... }事实上，点开LayoutInflater.from()进一步查看其实现： /** * Obtains the LayoutInflater from the given context. */ public static LayoutInflater from(Context context) { LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater; }可以了解到，第二种方法其实就是对第一种方法进行了一个简单的封装。 得到了LayoutInflater的实例之后，就可以调用其inflate()方法加载布局了。inflate()方法一共有四种： public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) public View inflate(XmlPullParser parser, @Nullable ViewGroup root) public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)不管我们调用哪一种方法的重载，最终都得调用到第四种方法。实践中，我们平时用得较多的可能是第一种和第三种重载，那么我们先来关注一下第三种方法。看看各个的参数有何作用。 看个例子。现在我们有一个线性布局文件 main.xml，包含有一个TextView: &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/layout_main&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/blue&quot; android:text=&quot;Text in LinearLayout&quot;/&gt; &lt;/LinearLayout&gt;在上面的 LinearLayout 中，我们将 gravity 属性配置为 center , 另有一个tv_test.xml： &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@color/red&quot; android:text=&quot;Hello NetEase&quot;&gt; &lt;/TextView&gt;在代码中加载布局： public class ActivityMain extends Activity { private LinearLayout mLinearLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mLinearLayout = (LinearLayout) findViewById(R.id.layout_main); LayoutInflater inflater = LayoutInflater.from(this); View buttonLayout = inflater.inflate(R.layout.tv_test, mLinearLayout, true); // mLinearLayout.addView(buttonLayout); } }这个时候我们看运行结果: 图1 作为对比，如果将第三个参数 attachToRoot 改为 false 探究其作用。 View buttonLayout = inflater.inflate(R.layout.tv_test, mLinearLayout, false);得到结果为： 图2 {% image http://i3.piimg.com/cfe65b9909457db1.png '' '' %} attachToRoot 设为 false 之后，buttonLayout 并没有附着在 mLinearLayout 上，所以得不到显示。不难预料，取消最后一行代码的注释，再运行。得到的结果将为图1。换句话说， View buttonLayout = inflater.inflate(R.layout.tv_test, mLinearLayout, true);和以下两行代码效果是等价的。 View buttonLayout = inflater.inflate(R.layout.tv_test, mLinearLayout, false); mLinearLayout.addView(buttonLayout);这时候先让我们的注意力重新回到inflate()的第一个重载方法。 View buttonLayout = inflater.inflate(R.layout.tv_test, mLinearLayout); mLinearLayout.addView(buttonLayout);运行结果如图：图3 运行结果跟图1是一样的。调整第二个参数为 null View buttonLayout = inflater.inflate(R.layout.tv_test, null); mLinearLayout.addView(buttonLayout);运行结果如下：图4 注意到加载进来的tv_test并没有居中对齐。 通过实际的例子，我们有了直观的印象。我们来看看相关的源码，追溯原因。 public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // Empty } if (type != XmlPullParser.START_TAG) { throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); } final String name = parser.getName(); if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) { // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) { // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); } } // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; } catch (Exception e) { InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; } finally { // Don&apos;t retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; } return result; } }参考代码，我们得知，只有在 root 非空且 attachToRoot 为真的条件下，源码才会执行 root.addView(temp, params)(加入的同时layout的属性也被设置了，所以我们看到 “Hello NetEase” 居中显示) ,不再需要我们在代码中手动执行。而我们使用两个参数的 inflate() 重载方法时，实际上是间接调用三个参数的 inflate() 方法，且只要 root 非空，attachToRoot 就会默认传入 true。所以可以看到图1和图3结果一致。 仔细看代码还能注意到，在进行条件判断时，都会先对root进行一个非空的判断。由此总结出，在第二个参数 root 为 null 的前提下，inflate()方法的第三个参数真假无意义，不起作用。而图2和图4的区别则是，root不为空，attachToRoot为false传入的view会对布局文件最外层的layout属性进行设置，其后调用addView将该View添加到父View中时，这些属性自动生效。所以我们看到 “Hello NetEase” 居中显示了。而图4传入 root 为 null，不会对layout属性设置。所以最终添加View时，没有居中对齐。 ###总结 root为null，attachToRoot将失去作用，真假无意义。 root不为null，attachToRoot设为true，则会给加载的布局文件指定一个父布局，即root。如果此时不设置 attachToRoot 的值，则默认为true。如设为false，则会将布局文件最外层的所有layout属性进行设置，其后调用addView将该View添加到父View中时，这些属性自动生效。 另外，在RecyclerView的Adapter中，调用onCreateViewHolder()时，attachToRoot 应设为 false @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_brands_top_layout, parent, false); return new BrandsTopHolder(view); } 很显然，我们应该让RecyclerView自己决定何时显示它的itemView。 参考文档： Android LayoutInflater原理分析，带你一步步深入了解View(一) Understanding Android’s LayoutInflater.inflate()","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://liangbin.xyz/tags/Android/"}]}]}